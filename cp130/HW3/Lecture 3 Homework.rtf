{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf350
{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red255\green204\blue102;\red131\green192\blue87;\red0\green160\blue190;
\red198\green124\blue72;\red120\green109\blue196;\red255\green255\blue102;\red65\green182\blue69;\red219\green44\blue56;
}
\margl1440\margr1440\vieww16000\viewh16420\viewkind0
{\*\background {\shp{\*\shpinst\shpleft0\shptop0\shpright0\shpbottom0\shpfhdr0\shpbxmargin\shpbymargin\shpwr0\shpwrk0\shpfblwtxt1\shpz0\shplid1025{\sp{\sn shapeType}{\sv 1}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 3355443}}{\sp{\sn fFilled}{\sv 1}}{\sp{\sn lineWidth}{\sv 0}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn bWMode}{\sv 9}}{\sp{\sn fBackground}{\sv 1}}}}}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f0\fs24 \cf2 HW 3\
\
In Homework 3 we will create 2 applications. First will be a Desktop application that advertises a service available via Bonjour. The second application will be an iPhone application that browses the local-link network for services of the type our Desktop application publishes. The iPhone app will also connect to the found service and send a message to it\
\
\
HW 3 Desktop will require the following for full points\
\
	- Use CFSocketCreate to create a network socket to listen for messages on\
	- Use CFSocketSetAddress to bind the socket to an address for listening\
	- Use NSFileHandle's initWithFileDescriptor method to create a fileHandle to read from\
	- Do asynchronous handling of the incoming connections with NSFileHandleConnectionAcceptedNotification\
	- Do asynchronous reading of incoming data with NSFileHandleDataAvailableNotification\
	- Use NSNetService to publish the Desktop's service and port\
	- Display messages received from clients in the application UI\
\
HW 3 Desktop Logical Flow :\
\
	- Create the socket for listening using CFSocketCreate\
	- Set the socket for reuse with setsockopt to aid debugging\
	- Bind the socket to an any address on your chosen port\
	- Wrap the socket's file descriptor ( CFSocketGetNative() ) in a new NSFileHandle\
	- Register for NSFileHandleConnectionAcceptedNotification notifications for the file handle\
	- Publish the service with Bonjour using NSNetService	\
	- When a connection notification happens\
		register for NSFileHandleDataAvailableNotification with the file handle\
		tell the file handle to read data asynchronously with waitForDataInBackgroundAndNotify:\
		tell the connection file handle to continue listening for new connections with acceptConnectionInBackgroundAndNotify\
\
	- When a data notification happens \
		Get the file handle from the data notification NSFileHandle readHandle = [notification object]\
		get available data from the file handle [readHandle availableData]\
		if there is no data\
			stop listening for read notifications from this handle and close it\
		else\
			read the data and use [readFileHandle waitForDataInBackgroundAndNotify]; to keep waiting for more data\
\
\
\
HW 3 Desktop Tips :\
\
Your socket creation code will look like :\
\
\pard\tx560\pardeftab560\ql\qnatural\pardirnatural

\fs22 \cf1 \CocoaLigature0 	\cf3 socket_\cf1  = CFSocketCreate\
		(\
			\cf4 kCFAllocatorDefault\cf1 ,\
			\cf5 PF_INET\cf1 ,\
			\cf5 SOCK_STREAM\cf1 ,\
			\cf5 IPPROTO_TCP\cf1 ,\
			\cf6 0\cf1 ,\
			\cf7 NULL\cf1 ,\
			\cf7 NULL\cf1 \
		 );
\fs24 \cf2 \CocoaLigature1 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf2 \
Get a file descriptor from your socket with :\
\pard\tx560\pardeftab560\ql\qnatural\pardirnatural

\fs22 \cf1 \CocoaLigature0 \
	\cf7 int\cf1  fileDescriptor = \cf4 CFSocketGetNative\cf1 (\cf3 socket_\cf1 );\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\fs24 \cf2 \CocoaLigature1 \
You can use this file descriptor to create the NSFileHandle you will use for connecting and reading\
\
\
Set your socket for reuse. If you don't do this, when debugging you will find that you get errors when trying to use the socket that it is already in use. The timeout for the socket to recycle can be loooonnnngggg :\
\
\
\pard\tx560\pardeftab560\ql\qnatural\pardirnatural

\fs22 \cf1 \CocoaLigature0 	\cf7 int\cf1  result = \cf4 setsockopt\cf1 (\
								fileDescriptor,\
								\cf5 SOL_SOCKET\cf1 ,\
								\cf5 SO_REUSEADDR\cf1 ,\
								(\cf7 void\cf1  *)&reuse,\
								\cf7 sizeof\cf1 (\cf7 int\cf1 )\
							);\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\fs24 \cf2 \CocoaLigature1 To being listening your Socket has to be bound to an address. The address is a BSD socket programming structure. It looks like this :\
\
\pard\tx560\pardeftab560\ql\qnatural\pardirnatural

\fs22 \cf1 \CocoaLigature0 	\cf7 struct\cf1  sockaddr_in address;\
	\cf5 memset\cf1 (&address, \cf6 0\cf1 , \cf7 sizeof\cf1 (address));\
	address.\cf4 sin_len\cf1  = \cf7 sizeof\cf1 (address);\
	address.\cf4 sin_family\cf1  = \cf5 AF_INET\cf1 ;\
	address.\cf4 sin_addr\cf1 .\cf4 s_addr\cf1  = \cf5 htonl\cf1 (\cf5 INADDR_ANY\cf1 );\
	address.\cf4 sin_port\cf1  = \cf5 htons\cf1 (\cf3 kListenPort\cf1 );
\fs24 \cf2 \CocoaLigature1 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf2 \
INADDR_ANY means we don't care what IP address is on the other side of our socket. kListenPort is the port you want your service to use. 8081 is a good choice that is not likely in use on your desktop. Wikipedia has a great list of ports official and unofficial : http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers\
\
\
To bind the address to the socket you need to wrap up the socket structure in an NSData or CFData object. I used CFData, but you can do the same with NSData and use toll free bridging to cast it to a CFData for use with CFSocketSetAddress :\
\
\pard\tx560\pardeftab560\ql\qnatural\pardirnatural

\fs22 \cf4 \CocoaLigature0 CFDataRef\cf1  addressData =\
	\cf4 CFDataCreate\cf1 (\cf7 NULL\cf1 , (\cf7 const\cf1  \cf4 UInt8\cf1  *)&address, \cf7 sizeof\cf1 (address));\
	\
	[(\cf7 id\cf1 )addressData \cf4 autorelease\cf1 ];\
	\
	\
	\cf8 // bind socket to the address\cf1 \
	\cf7 if\cf1  (\cf4 CFSocketSetAddress\cf1 (\cf3 socket_\cf1 , addressData) != \cf4 kCFSocketSuccess\cf1 )\
	\{\
		[\cf3 appController_\cf1  \cf3 appendStringToLog\cf1 :\cf9 @"Unable to bind socket to address"\cf1 ];\
		\cf7 return\cf1  \cf7 NO\cf1 ;\
	\}\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\fs24 \cf2 \
After your socket is set up, you'll want to wrap the file descriptor associated with it in a NSFileHandler and register for connection notifications :\
\
\pard\tx560\pardeftab560\ql\qnatural\pardirnatural

\fs22 \cf1 	\cf3 connectionFileHandle_\cf1  = [[\cf4 NSFileHandle\cf1  \cf4 alloc\cf1 ] \cf4 initWithFileDescriptor\cf1 :fileDescriptor \cf4 closeOnDealloc\cf1 :\cf7 YES\cf1 ];\
	\
	[[\cf4 NSNotificationCenter\cf1  \cf4 defaultCenter\cf1 ]\
		\cf4 addObserver\cf1 :\cf7 self\cf1 \
		\cf4 selector\cf1 :\cf7 @selector\cf1 (\cf3 handleIncomingConnection\cf1 :) \
	        \cf4 name\cf1 :\cf4 NSFileHandleConnectionAcceptedNotification\cf1 \
		  \cf4 object\cf1 :\cf7 nil\cf1 ];\
	\
	[\cf3 connectionFileHandle_\cf1  \cf4 acceptConnectionInBackgroundAndNotify\cf1 ];
\fs24 \cf2 \CocoaLigature1 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf2 \
\
You'll then need to handle NSFileHandleConnectionAcceptedNotifications. \
\
\pard\tx560\pardeftab560\ql\qnatural\pardirnatural

\fs22 \cf1 \CocoaLigature0 -(\cf7 void\cf1 ) handleIncomingConnection:(\cf4 NSNotification\cf1 *)notification\
\{\
	\cf4 NSDictionary\cf1 *	userInfo			=	[notification \cf4 userInfo\cf1 ];\
	\cf4 NSFileHandle\cf1 *	readFileHandle		=	[userInfo \cf4 objectForKey\cf1 :\cf4 NSFileHandleNotificationFileHandleItem\cf1 ];\
	\
    \cf7 if\cf1 (readFileHandle)\
	\{\
		[[\cf4 NSNotificationCenter\cf1  \cf4 defaultCenter\cf1 ]\
		 \cf4 addObserver\cf1 :\cf7 self\cf1 \
		 \cf4 selector\cf1 :\cf7 @selector\cf1 (\cf3 readIncomingData\cf1 :)\
		 \cf4 name\cf1 :\cf4 NSFileHandleDataAvailableNotification\cf1 \
		 \cf4 object\cf1 :readFileHandle];\
		\
		[\cf3 appController_\cf1  \cf3 appendStringToLog\cf1 :\cf9 @"Opened an incoming connection"\cf1 ];\
		\
        [readFileHandle \cf4 waitForDataInBackgroundAndNotify\cf1 ];\
    \}\
	\
	[\cf3 connectionFileHandle_\cf1  \cf4 acceptConnectionInBackgroundAndNotify\cf1 ];\
\}\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\fs24 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf2 \CocoaLigature1 Finally you'll need to handle data available notifications. The trick here is that you have to indicate to keep being notified of new data if you don't get all the bytes :\
\
\pard\tx560\pardeftab560\ql\qnatural\pardirnatural

\fs22 \cf1 \CocoaLigature0 - (\cf7 void\cf1 ) readIncomingData:(\cf4 NSNotification\cf1 *) notification\
\{\
	\cf4 NSFileHandle\cf1 *	readFileHandle	= [notification \cf4 object\cf1 ];\
	\cf4 NSData\cf1 *			data			= [readFileHandle \cf4 availableData\cf1 ];\
	\
	\cf7 if\cf1  ([data \cf4 length\cf1 ] == \cf6 0\cf1 )\
	\{\
		[\cf3 appController_\cf1  \cf3 appendStringToLog\cf1 :\cf9 @"No more data in file handle, closing"\cf1 ];\
		\
		[\cf7 self\cf1  \cf3 stopReceivingForFileHandle\cf1 :readFileHandle \cf3 closeFileHandle\cf1 :\cf7 YES\cf1 ];\
		\cf7 return\cf1 ;\
	\}	\
	\
	[\cf3 appController_\cf1  \cf3 appendStringToLog\cf1 :\cf9 @"Got a message :"\cf1 ];\
	[\cf3 appController_\cf1  \cf3 appendStringToLog\cf1 :[\cf4 NSString\cf1  \cf4 stringWithUTF8String\cf1 :[data \cf4 bytes\cf1 ]]];\
	\
	\cf8 // wait for a read again\cf1 \
	[readFileHandle \cf4 waitForDataInBackgroundAndNotify\cf1 ];	\
\}
\fs24 \cf2 \CocoaLigature1 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf2 \
Publishing the service is very easy :\
\
\pard\tx560\pardeftab560\ql\qnatural\pardirnatural

\fs22 \cf1 \CocoaLigature0 	\cf4 NSNetService\cf1 * netService = [[\cf4 NSNetService\cf1  \cf4 alloc\cf1 ] \cf4 initWithDomain\cf1 :\cf9 @""\cf1  \
												 \cf4 type\cf1 :\cf3 kServiceTypeString\cf1 \
												 \cf4 name\cf1 :\cf3 kServiceNameString\cf1  \
												 \cf4 port\cf1 :\cf3 kListenPort\cf1 ];\
	\cf8 // publish on the default domains\cf1 \
	\
    [netService \cf4 setDelegate\cf1 :\cf7 self\cf1 ];\
    [netService \cf4 publish\cf1 ];\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\fs24 \cf2 \CocoaLigature1 \
Note the use of an empty string for the domain. This indicates to use the default domains which is fine for our purposes as it includes the ".local." domain. \
\
\
You can use anything you want for the Service Name, though you should follow the documentations suggestions for service type. The port should match the port you set the socket to listen to. I used :\
\
\pard\tx560\pardeftab560\ql\qnatural\pardirnatural

\fs22 \cf1 \CocoaLigature0 NSString* \cf7 const\cf1 			kServiceTypeString		= \cf9 @"_uwcelistener._tcp."\cf1 ;\
NSString* \cf7 const\cf1 			kServiceNameString		= \cf9 @"HW3 listen service"\cf1 ;\
\cf7 const\cf1 	\cf7 int\cf1 				kListenPort				= \cf6 8081\cf1 ;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\fs24 \cf2 \
You can use the application Bonjour Browser to see if your service is published on the local network. \
\
\
\pard\tx560\pardeftab560\ql\qnatural\pardirnatural

\fs22 \cf1 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\fs24 \cf2 \CocoaLigature1 HW 3 iPhone will require the following for full points\
\
	- Use NSNetServiceBrowser to find and display all services matching the type you publish in the Desktop client in a Table View\
	- Use NSNetService to resolve the addresses for all services found and display the address in the table view\
	- When clicking on a table view cell, attempt to connect to that service.\
	- Present UI for the user to enter a text message to send to the service\
	- Use NSNetService getInputStream:outputStream: to connect to the services socket and read from it\
	- Use NSOutputStream \CocoaLigature0 write:maxLength: to do a synchronous write of an arbitrary text message to the client\CocoaLigature1 \
\
	\
\
HW 3 iPhone Logical Flow : \
\
	- Browse services with NSNetSerivceBrowser when the application is launched\
	- As your NSNetServiceBrowser delegate is notified of services, add them to the table view's data\
	- Attempt to resolve the address for each service found\
	- As delegate is notified of resolved addresses, update the table view\
\
	- If user selects a table view cell, push a new navigation view\
	\
	- When user clicks send message in connection detail view connect and send user's text string to service using NSOutputStream\
\
\
\
\
\
HW 3 iPhone Tips :\
\pard\tx560\pardeftab560\ql\qnatural\pardirnatural

\fs22 \cf1 \CocoaLigature0 \
\

\fs24 \cf2 \CocoaLigature1 We will provide you with an iPhone project skeleton so you don't have to fuss with the UI if you do not want to. You can just fill in the network browsing and message sending\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf2 \
Start by creating the service browser and kicking it off looking for your service type in the default domains :\
\
\pard\tx560\pardeftab560\ql\qnatural\pardirnatural

\fs22 \cf1 \CocoaLigature0    \cf3 browser_\cf1 		= [[\cf4 NSNetServiceBrowser\cf1  \cf4 alloc\cf1 ] \cf4 init\cf1 ];\
    [\cf3 browser_\cf1  \cf4 setDelegate\cf1 :\cf7 self\cf1 ];\
    [\cf3 browser_\cf1  \cf4 searchForServicesOfType\cf1 :\cf3 kServiceTypeString\cf1  \cf4 inDomain\cf1 :\cf3 kSearchDomain\cf1 ];\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\fs24 \cf2 \CocoaLigature1 \
When a service is found, update your local store of services. Go ahead and start resolving the address with a reasonable timeout here and update the UI if appropriate :\
\
\pard\tx560\pardeftab560\ql\qnatural\pardirnatural

\fs22 \cf1 \CocoaLigature0 - (\cf7 void\cf1 )netServiceBrowser:(\cf4 NSNetServiceBrowser\cf1  *)aNetServiceBrowser \
           didFindService:(\cf4 NSNetService\cf1  *)aNetService \
               moreComing:(\cf7 BOOL\cf1 )moreComing \
\{\
    \cf4 NSLog\cf1 (\cf9 @"Adding new service"\cf1 );\
    [\cf3 services_\cf1  \cf4 addObject\cf1 :aNetService];\
   \
	[aNetService \cf4 setDelegate\cf1 :\cf7 self\cf1 ];\
    [aNetService \cf4 resolveWithTimeout\cf1 :\cf6 5.0\cf1 ];\
	\cf8 // timeout is in seconds\cf1 \
	\
    \cf7 if\cf1  (!moreComing)\
	\{\
        [\cf7 self\cf1 .\cf4 tableView\cf1  \cf4 reloadData\cf1 ];        \
    \}\
\}\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\fs24 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf2 \CocoaLigature1 \
Be sure to handle services that go away with :\
\
\pard\tx560\pardeftab560\ql\qnatural\pardirnatural

\fs22 \cf1 \CocoaLigature0 - (\cf7 void\cf1 )netServiceBrowser:(\cf4 NSNetServiceBrowser\cf1  *)aNetServiceBrowser \
         didRemoveService:(\cf4 NSNetService\cf1  *)aNetService \
               moreComing:(\cf7 BOOL\cf1 )moreComing \
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\fs24 \cf2 Handle success and failure to resolve addresses of services with :\
\pard\tx560\pardeftab560\ql\qnatural\pardirnatural

\fs22 \cf1 \
- (\cf7 void\cf1 )netServiceDidResolveAddress:(\cf4 NSNetService\cf1  *)sender\
\{\
	\cf4 NSLog\cf1 (\cf9 @"RESOLVED net service with name %@ and type %@"\cf1 , [sender \cf4 name\cf1 ], [sender \cf4 type\cf1 ]);\
	[\cf7 self\cf1 .\cf4 tableView\cf1  \cf4 reloadData\cf1 ];\
\}\
\
- (\cf7 void\cf1 )netService:(\cf4 NSNetService\cf1  *)sender didNotResolve:(\cf4 NSDictionary\cf1  *)errorDict\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\fs24 \cf2 \
When a service is selected, connecting is easy. Just grab the output stream associated with the service using NSNetService :\
\pard\tx560\pardeftab560\ql\qnatural\pardirnatural

\fs22 \cf1 \
	[\cf3 service_\cf1  \cf4 getInputStream\cf1 :\cf7 NULL\cf1  \cf4 outputStream\cf1 :&\cf3 outputStream_\cf1 ];\
	\
	\cf7 if\cf1  ( \cf3 outputStream_\cf1  != \cf7 nil\cf1  )\
	\{\
		[\cf3 outputStream_\cf1  \cf4 open\cf1 ];\
		\cf3 statusLabel_\cf1 .\cf4 text\cf1  = \cf9 @"Connected to service."\cf1 ;\
	\}\
	\cf7 else\cf1 \
	\{\
		\cf3 statusLabel_\cf1 .\cf4 text\cf1  = \cf9 @"Could not connect to service"\cf1 ;\
	\}\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\fs24 \cf2 \
Finally, you can send the message synchronously :\
\
\pard\tx560\pardeftab560\ql\qnatural\pardirnatural

\fs22 \cf1 	\cf4 NSString\cf1 * messageText = \cf3 messageTextView_\cf1 .\cf4 text\cf1 ;\
	\
	\cf7 const\cf1  \cf4 uint8_t\cf1 *	messageBuffer = (\cf7 const\cf1  \cf4 uint8_t\cf1 *)[messageText UTF8String];\
	\cf4 NSUInteger\cf1 		length = [messageText \cf4 lengthOfBytesUsingEncoding\cf1 :\cf4 NSUTF8StringEncoding\cf1 ];\
	[\cf3 outputStream_\cf1  \cf4 write\cf1 :messageBuffer \cf4 maxLength\cf1 :length];
\fs24 \cf2 \
}